import numpy as np
import pandas as pd
def Find_R(roll, pitch, yaw):

    yaw_hard_coded_calibration = np.radians(63)   
    yaw =  (yaw- yaw_hard_coded_calibration)
    
    roll = roll - np.radians(-5)
    # Convert Euler angles to rotation matrices
    R_roll = np.array([[1, 0, 0],
                    [0, np.cos(roll), -np.sin(roll)],
                    [0, np.sin(roll), np.cos(roll)]])

    R_pitch = np.array([[np.cos(pitch), 0, np.sin(pitch)],
                        [0, 1, 0],
                        [-np.sin(pitch), 0, np.cos(pitch)]])

    R_yaw = np.array([[np.cos(yaw), -np.sin(yaw), 0],
                    [np.sin(yaw), np.cos(yaw), 0],
                    [0, 0, 1]])

    # Combine individual rotation matrices to obtain the overall rotation matrix
    rotation_matrix = np.dot(np.dot(R_yaw, R_pitch), R_roll)
    
    return rotation_matrix

def Find_t(x, y, z):
    translation_vector = np.array([x,y,z])
    return translation_vector

def Find_External_matrix(rotation_matrix,translation_vector):
    external_matrix = np.zeros([4,4])
    external_matrix[:3,:3] = rotation_matrix.T
    external_matrix[:3,3] = 1* np.dot(rotation_matrix.T,translation_vector.T)
    external_matrix[3,:] = np.array([0,0,0,1])


    #final rotation
    y_rot = - np.radians(90)
    R_pitch = np.array([[np.cos(y_rot), 0, np.sin(y_rot)],
                        [0, 1, 0],
                        [-np.sin(y_rot), 0, np.cos(y_rot)]])
    

    R = np.zeros([4,4])
    R[:3, :3] = R_pitch
    R[3, :] = np.array([0,0,0,1])

    external_matrix = np.dot(R, external_matrix)
    return external_matrix

def project_points(projection_matrix, corners_drone):
    """
    projection_matrix: The projection matrix based on the intrinsic camera calibration.
    points: Nx[x,y,z,1.0] np.array of the points that need to be projected to the camera image from drone frame.
    return: Nx[u,v] rounded coordinates of the points in the camera image as int data type.
    """
    #-------------------------Miquel / the correct projection------------------
    assert corners_drone.shape[-1] == 4
    uvs = []
    # points = points[:,:3]
    # print(corners_drone)
    for row in corners_drone:
        projected_points_homogeneous = projection_matrix @ row.T

        # Normalize the homogeneous coordinates
        normalized_points = (projected_points_homogeneous[:2] / projected_points_homogeneous[2]).T

        # Round the coordinates to integers
        uvs.append(np.round(normalized_points).astype(int))
    uvs = np.array(uvs)
    # print(uvs)
    
    return uvs





#---------------------------MAIN-----------------------------------------------------------------


#camera projection matrix 
projection_matrix  = np.array([[300,0,120,0],
                               [0,300,260,0],
                               [0,0,1,0],
                               [0,0,0,1]])

# Replace 'file_path.csv' with the actual path to your CSV file
# file_path = './cyberzoo_poles_panels_mats/20190121-142943.csv'
file_path = './sim_poles_panels_mats/20190121-161955.csv'

# Read the CSV file into a DataFrame
df = pd.read_csv(file_path)

# Separate each column into individual variables
x_col = df.iloc[:, 1]  
y_col = df.iloc[:, 2]  
z_col = df.iloc[:, 3]

roll_col = df.iloc[:, 7] 
pitch_col = df.iloc[:, 8] 
yaw_col = df.iloc[:, 9] 


#definig final array for corner pixel coordinates (3D)
uvs = np.zeros((x_col.shape[0],4, 2))

#main loop for finding all 4 corners for a datapoint
for i in range(0, x_col.shape[0]):

    #for now for every coordinate update we want original corner coordinates
    cor_coord_org = np.array([[4,4.,0.,1.],
                          [-4.,-4.,0.,1.],
                          [4.,-4.,0.,1.],
                          [-4.,4.,0.,1.]])


    #Rotation
    R_rotation_matrix = Find_R(roll_col[i], pitch_col[i], yaw_col[i])

    #Translation
    t_vector = Find_t(x_col[i],y_col[i],z_col[i])
    

    #Find 3D corner coordinates in camera frame
    External_matrix = Find_External_matrix(R_rotation_matrix,t_vector)

    cor_coord_camera = np.dot(External_matrix,cor_coord_org.T).T
    #Find corner pixel coordinates for the image 
    uvs_row = project_points(projection_matrix, cor_coord_camera)
    if i ==0:
        print(cor_coord_camera)

    #fill a row in the final uvs matrix
    uvs[i,:,:] = uvs_row


    #for testing save every 12 datapoint (because per frame you have about 12 datapoints)
    uvs_testing = uvs[::11]
    # Save the array to the specified file path
    np.save("./saved_numpy.npy", uvs_testing)
    

print(uvs_testing[0])